---
title: "week2Notes"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## the apply family!!

the apply family of functions iterates over an object and apply a function. 

- use this instead of loops if you want to do soemthing ot a row or a column
  
Why?
- becasue R can find out what to look at and prepare for what it needs to do. a lot more direct and to the point. in a for loop, it just looks at all the data, so it will manipulate the data faster

###apply()

if you want ot modify or do soemthing to the rows or columns of a matrix or datafram: apply() rows: 1     columns: 2
*for every column in data set, it gives the summary*
```{r}
apply(mtcars,2,summary) 
#this returns a matrix

apply(mtcars, 2, mean)
#this is a list 

grades= data.frame(test1=rnorm(25,75,10),test2=rnorm(25,75,10),test3=rnorm(25,75,10))

# rnorm (size of sample, mean, std deviation)

grades

apply(grades,1,mean)

#syntax: apply(data,1 for row or 2 for column, function)

```
##tapply()

if you want to apply a function to a subset of data based on characteristics of the data, use tapply()

only works on one column at a time

for example, if you want to group cars by manufacturer.

```{r}
grades= data.frame(test1=rnorm(25,75,10),test2=rnorm(25,75,10),test3=rnorm(25,75,10), team=sample(c("blue","red"),25,replace= TRUE))

#each test is a colum and giving the data in each of the colums normalized distribution of data.  replace=true means we can sample it more than onece!

grades

tapply(grades$test1, grades$team, mean)


```


##lapply

if your input is a list (which can contain muliple data types),use lapply() (list supply!)

```{r}
#first generate different size data sample

sec01=rnorm(25,85,10)
sec02=rnorm(15,75,6)
sec03=rnorm(18,80,5)

section=list(sec01,sec02,sec03)

#section

lapply(section,mean)
```


##sapply()

if you are returning one value from a funciton and you want it ot be a vector or want R to guess what th eoutput should be, use sapply() (simple?)
its like lapply, but instead of a list, its in a better looking and better fucnitong data structure

```{r}
sapply(section,mean)
```

you can use this to add colums to datafram

```{r}
mtcars

#mpg to kpl- mpg/2.352

mtcars$kpl=sapply(mtcars$mpg, function(x) x/2.352)

#the 'function' is taking an x (which is equivalent to for x in mtcars mpg) 
#this function is annonymous because it dosnt have a name
mtcars
```

```{r}
mpjudge<-function(x){
  if (x>=25){
    return("good")
  }
  else{
    return("bad")
  }
}

mtcars$judge=sapply(mtcars$mpg,mpjudge)
mtcars
```
###
mypoints=sapply(1:100,setPoint()) #this wont work! wont work becasue setpoint dosnt have any perameters. instead, create an annonymous function that calls setpoint

```{r}
mypoints=sapply(1:100,function(x){setPoint()}) 
```




##vapply

allows you to tell R what kind of datatype you want to be returned. the 'numeric' is specifying what kind of data type. sapply is better? 1 is the number of rows you are expecting back

```{r}
vapply(section, mean,numeric(1))
```






